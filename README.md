#  Signdrop - Secure File Sharing with Cryptography

A web-based demonstration of secure cryptographic file sharing with encryption, digital signatures, and revocation capabilities.

##  Features

**AES-256-GCM Encryption** - Confidentiality with authenticated encryption  
**RSA-PSS Digital Signatures** - Authentication & Non-repudiation  
**RSA Key Exchange** - Secure symmetric key distribution  
# Signdrop — Secure File Sharing (Demo)


**Contents of this README**
- **Cryptographic algorithms used** — high-level description of encryption, hashing, key-exchange and signature algorithms used.
- **Libraries and tools** — why the chosen libraries were used and alternatives for production.
- **Key management strategy** — where and how keys are generated, stored, and distributed in this demo and recommended production changes.
- **Implementation details** — file-by-file overview and where cryptography is applied in code.
- **Security analysis** — threat model, mitigations, and recommended hardening steps.
- **How to run** — quick commands to run the demo locally.

## Cryptographic Algorithms Used

- **Encryption (Confidentiality & Integrity)**: AES-256 in Galois/Counter Mode (AES-256-GCM).
    - Provides both confidentiality and an authentication tag (AEAD), protecting against tampering and providing detection of altered ciphertext.

- **Key Encapsulation (Key Exchange for Symmetric Key)**: RSA-OAEP (RSA with Optimal Asymmetric Encryption Padding) to encrypt per-file AES keys when sending to a recipient.
    - Used as the KEM: a fresh random AES key encrypts the payload, and that AES key is encrypted for the recipient using their RSA public key.

- **Signatures (Authentication & Non-repudiation)**: RSA-PSS with SHA-256.
    - Sign the raw file bytes (or canonical representation) with the sender's RSA private key; the receiver verifies with the sender's public key.

- **Hashing**: SHA-256 is used implicitly by RSA-PSS and for any ID hashing needs (file IDs, short fingerprints).

Design note: This demo uses an RSA-based hybrid approach (RSA + AES) for clarity reasons. In production, ECIES or X25519 + AEAD are often more efficient.

## Libraries and Tools - choices and justification

- `cryptography` (Python): chosen for backend crypto primitives.
    - Justification: well-maintained, Pythonic API, uses OpenSSL under the hood and exposes secure high-level APIs (AEAD, RSA-PSS, OAEP) while discouraging unsafe low-level operations.
    - Alternative production choices: libsodium (easy, high-level modern primitives like X25519/ChaCha20-Poly1305), or directly using OpenSSL with vetted wrappers if required.

- `Flask`: minimal HTTP API framework for teaching/demo purposes.

- Vanilla HTML+JS frontend: avoids Node/npm dependency to keep the demo runnable in constrained environments.

Why not OpenSSL/Libsodium directly inside this demo? Using `cryptography` gives a safe, cross-platform Python API. For higher performance or modern curve-based systems, libsodium (or `pynacl`) is recommended in production.

## Key Management Strategy

This section splits the demo's approach (what is implemented) from recommended production practices.

Demo (what this repository implements):
- Each user (e.g., Alice, Bob) gets an RSA-2048 key pair generated by the backend on registration. Private keys are stored in memory for the running process (this is fine for the short-lived demo but not for production).
- Per-file symmetric keys: a fresh random 256-bit AES key is generated for every file sent.
- Distribution: the per-file AES key is encrypted with the recipient's RSA public key (RSA-OAEP) and stored alongside the ciphertext in the in-memory package.

Recommended production key-management (do not rely on the demo storage model):
- Persist keys securely (encrypted at rest) or use a dedicated Key Management System (KMS) or Hardware Security Module (HSM).
- Use short-lived credentials and rotate keys regularly; maintain key versioning and a revocation list.
- Protect private keys with OS-level permissions, encryption at rest, and restrict access with RBAC.
- Use TLS for all transport to protect keys during retrieval.

Key lifecycle notes:
- Generation: use cryptographically secure RNG (the demo uses the `cryptography` library RNG).
- Storage: demo = process memory; production = HSM/KMS or encrypted key store.
- Distribution: only share public keys; verify public keys out-of-band or via a trusted directory/certificate to prevent MITM.

## Implementation Details (Code Overview)

- `backend/app.py` — central file. Key functions and endpoints:
    - `generate_rsa_keypair()` / registration endpoint: creates RSA private/public keypair for a user.
    - `encrypt_aes(plaintext, key)` / `decrypt_aes(encrypted_blob, key)`: AES-256-GCM encryption and decryption helpers (nonce/IV handling, tag concatenation/encoding).
    - `sign_data(data, private_key)` / `verify_data(data, signature, public_key)`: RSA-PSS sign/verify helpers.
    - `POST /api/send-file`: workflow — generate AES key; sign plaintext; encrypt plaintext+signature with AES-GCM; encrypt AES key with recipient RSA (OAEP); store package and return file ID.
    - `POST /api/receive-file`: workflow — check revocation; decrypt AES key with recipient RSA private key; decrypt AES-GCM payload; split out signature and verify it with sender's public key; return result and signature validity flag.
    - `POST /api/revoke/<file_id>`: mark or remove package to implement revocation.
    - (Optional) `/api/corrupt-file`: helper for classroom tampering tests.

- `index.html` — minimal frontend.
    - Calls `POST /api/register` to create users and fetch public keys.
    - Calls `POST /api/send-file` with sender, recipient, and plaintext content.
    - Calls `POST /api/receive-file` with recipient identity and file ID to fetch and verify contents.

- `server.py` — simple static file server for the `index.html` frontend.

Integration notes:
- The signing step is performed before encryption (sign-then-encrypt). This gives the receiver an authenticated assertion that the sender created the data; encrypting the signature along with the payload keeps the signature confidential until the intended recipient decrypts.
- AES-GCM's authentication tag protects both the payload and the included signature from tampering.

## Security Analysis — threat model & mitigations

Threats considered :

- Tampering (active modification of ciphertext): mitigated by AES-GCM AEAD, tampering causes decryption/authentication failure.

- Wrong recipient / confidentiality breach: mitigated by encrypting the AES key with recipient's public key (RSA-OAEP); only the holder of the recipient private key can recover the symmetric key and decrypt content.

- Forged messages (sender impersonation): mitigated by RSA-PSS signatures; verification with the sender's public key detects forgeries.

- Key compromise (private key leakage): demo risk, private keys kept in memory. Production mitigation, use HSM/KMS, rotate keys, maintain revocation.

- Replay attacks: include timestamps or nonces in metadata when needed. The demo stores packages and expects fresh fetches; for production, include validity windows and signed timestamps.

- Man-in-the-middle (MITM) stealing public keys: mitigate by authenticating public keys via PKI, certificates, or an out-of-band trust bootstrapping. The demo trusts the server-generated keys.

- Side-channel and implementation bugs: use tested libraries and avoid custom crypto primitives. We rely on `cryptography`, which wraps OpenSSL; keep dependencies updated.

Additional mitigation suggestions for production:
- Always run over TLS (HTTPS) to protect transport-level secrets and metadata.
- Use authenticated user accounts and authorization checks for every endpoint.
- Rate-limit sensitive endpoints and log suspicious access.
- Add integrity checks and audits for key provisioning actions.
- Implement key rotation and a robust revocation mechanism with secure notification to recipients.

Limitations of this demo:
- Private keys are stored in process memory and are ephemeral, not suitable for production.
- The Flask dev server is not hardened,  use a WSGI server (Gunicorn/Uvicorn) behind a TLS-terminating reverse proxy for production.
- No persistent database for files or users in the demo (everything is in-memory). Use an encrypted DB for persistence in production.

## How to run 

1. Create the Python venv and install dependencies:

```powershell
cd C:\Users\USER\Documents\signdrop_web_app2
python -m venv .\backend\venv
.\backend\venv\Scripts\Activate.ps1
pip install -r .\backend\requirements.txt
```

2. Start the backend in a terminal (recommended with venv active):

```powershell
cd C:\Users\USER\Documents\signdrop_web_app2\backend
.\venv\Scripts\python.exe app.py
# Flask dev server listens on http://127.0.0.1:5000 by default
```

3. In a second terminal, start the static frontend server:

```powershell
cd C:\Users\USER\Documents\signdrop_web_app2
python server.py
# Open http://localhost:8000 in your browser
```

## Suggested next steps / hardening roadmap

- Move private key storage to an HSM or cloud KMS.
- Add persistent storage (encrypted DB) for files and metadata, with access controls.
- Replace RSA-2048 with modern ECC (e.g., X25519 / Ed25519) and AEAD (ChaCha20-Poly1305) using libsodium for performance and smaller key sizes.
- Add end-to-end tests and automated test harness for the tampering / wrong-recipient scenarios.
- Add unit tests and CI/CD checks (dependency scanning, SAST).




